{"note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Java statsd client","google":"","tagline":"AppFirst Java Statsd Client","body":"![Appfirst](http://www.appfirst.com/img/appfirst-logo.png)\r\nStatsd Java Clients by [AppFirst](http://www.appfirst.com)\r\n====================================\r\n\r\nFor Statsd, here's a definition I like from [Native StatsD integration with Gauges and Percentiles](http://blog.librato.com/2012/05/new-statsd-integration-with-gauges-and.html) by Mike Heffner from Librato.\r\n\r\n> StatsD is a simple network daemon that continuously receives metrics pushed over UDP and periodically sends aggregate metrics to upstream services like Graphite and Librato Metrics. Because it uses UDP, clients (for example, web applications) can ship metrics to it very fast with little to no overhead. This means that a user can capture multiple metrics for every request to a web application, even at a rate of thousands of requests per second. Request-level metrics are aggregated over a flush interval (default 10 seconds) and pushed to an upstream metrics service.\r\n\r\nThere are currently 3 types of stats: [Counting](#couting), [Timing](#timing) and [Gauge](#gauge). Etsy has defined the [concepts](https://github.com/etsy/statsd#concepts). \r\n\r\nFor API specification please see the documentation under `src/main/javadoc`\r\n\r\nInclude the `target/jar/statsd.jar` to start!\r\n\r\n## Use Statsd Client\r\n-------------------\r\n\r\nTo use Statsd client, it's ridiculously easy and straightforward:\r\n\r\n\tStatsdClient client = new AFClient();\r\n\tclient.increment(\"some_bucket\");\r\n\t\r\nBy doing this, you sent a message look like this:\r\n\r\n\tsome_bucket:1|c\r\n\t\r\nThat's it! Use it anywhere in your code to get statistical data over time, the server will do everything for you. Currently there are several implementation available in the wild, such as the original [etsy/statsd](https://github.com/etsy/statsd) implementation and [AppFirst Collector][collector]'s seamless integration. Here is [a list of them](http://joemiller.me/2011/09/21/list-of-statsd-server-implementations/).\r\n\r\n\r\n###AppFirst Extension:\r\n\r\nThere are currently two implementation of Statsd client, [UDPClient and AFClient](#about-transport) to sent messages. So it's self-explanatory: to send through UDP, use UDPClient, to send through with AppFirst Collector (please [install the collector][collector] before you do), use AFClient. Here is a complete example:\r\n\r\n\timport com.appfirst.statsd.StatsdClient;\t\r\n\timport com.appfirst.statsd.AFClient;\r\n\t\r\n\tpublic class SomeClass{\r\n\r\n\t\tpublic static void main(){\r\n\r\n\t\t\tStatsdClient client = new AFClient();\r\n\t\t\tclient.increment(\"bucket\");\r\n\t\t}\r\n\t}\r\n\r\nWe also accept message as extension. On the graph the message will be display for each tick.\r\n<!--We need a example pic to demostrate here.-->\r\nThe format will be position-invariant:\r\n\r\n\tbucket: field0 | field1 | field2                 | field3\r\n\tbucket: value  | unit   | sampele_rate/timestamp | message\r\n\r\ne.g. a counter message and a gauge message look like the following:\r\n\r\n\tbucket:2|c|0.1|some_message\r\n\tbucket:333|g|1344570108|some_message\r\n\r\nwhen message is there, we always keep field2 even if it's blank:\r\n\r\n\tbucket:10|ms||some_message\r\n\r\nPlease see below for detail usage.\r\n\t\r\n## Counting\r\n-------------------\r\n**increment(buckets, sample_rate=1, message=None)**\r\n\t\r\nTo increment one or more stats counters, message is available with **[AppFirst Extended Format](#appfirst-extension)** only.\r\n\t    \t\r\nHere's an example (the second example are using [sample rate](#sample-rate)):\r\n\r\n\tStatsdClient client = new AFClient();\r\n\tclient.increment(\"some.int\", \"some.int2\");\r\n\t\r\n'c' is the unit for counter. This will send messages:\r\n\r\n\tsome.int:1|c\r\n\tsome.int2:1|c\r\n\r\n**decrement(buckets, sample_rate=1, message=None)**\r\n\r\nTo decrement one or more stats counters.\r\n\r\n\tStatsdClient client = new AFClient();\r\n\tclient.decrement(\"some.int\");\r\n\t\r\nAnd this will send message:\r\n\r\n\tsome.int:-1|c\r\n\r\n**update_stats(buckets, delta=1, sampleRate=1, message=None)**\r\n\r\nTo updates one or more stats counters by arbitrary amounts:\r\n\r\n\tStatsdClient client = new AFClient();\r\n\tclient.updateStats(5, \"some.int\");\r\n\tclient.updateStats(2, 0.5, \"some.int\");\r\n\tclient.updateStats(3, \"act1\", 1.0, \"some.int\")\r\n\t\r\nAnd the message for these are:\r\n\r\n\tsome.int:5|c\r\n\tsome.int:2|c|@0.5\r\n\tsome.int:3|@1.0|act1\r\n\r\n###Sample Rate\r\n\r\nChances are that your application sends lots of counting through UDP/AFTransport which might significantly hurt your performance, Sampling is here to the rescue.\r\n\r\nBy pass in a `sampleRate`, the client will only sent `(sampleRate * 100)%` of the **counter** messages by **random** and discard the rest \"unlucky\" ones. The message will carry this rate, and the server will restore the count by multiply `1/sampleRate` upon reception (of course, we lose the precision).\r\n\r\nBy default the sample_rate is alway 1, which means every message will be sent.\r\n\r\nNote this is a **counter** only feature, `sampleRate` for **timer** and **gauge** will be ignored.\r\n\r\n\r\n## Timing\r\n-------------------\r\n**timing(bucket, elapse, message=None)**\r\n\r\nLog timing information, in another word, measuring the elapsed time for a certain action.\r\nOptionally, you can also define message (with **[AppFirst Extended Format](#appfirst-extension)** only).\r\n\r\n\tStatsdClient client = new AFClient();\r\n\tclient.timing(\"some.time\", 500);\r\n\tclient.timing(\"some.time\", 300, \"message\");\r\n\r\nUOM for timing is always 'ms' (milli-second). A message like this is sent:\r\n\r\n\tsome.time:500|ms\r\n\tsome.time:300|ms||message\r\n\r\n## Gauge\r\n-------------------\r\n**gauge(bucket, reading, message=None)**\r\n\r\nLog gauge information, in another word, the status of the moment. The client will send the message with a timestamp of now.\r\n\r\n\tStatsdClient client = new AFClient();\r\n\tclient.gauge(\"some.gauge\", 500);\r\n\r\nThe unit for gauge is 'g', here is the message:\r\n\r\n\tsome.gauge:500|g\r\n\r\nAgain, you can also define message (with **[AppFirst Extended Format](#appfirst-extension)** only)\r\n\t\r\n\r\n## UDPClient and AFClient\r\n-------------------\r\nIn order to send StatsD message in different ways, you can have different implementation to `StatsdClient` interface. Currently we have `UDPClient` and also `AFClient` if you want to communicate with [AppFirst Collector][collector]. `AFClient` will send statsd message through posix message queue, and send UDP message intead when fail to do so. If you are using it under windows, you should enable UDP server of the collector. Please send email to <support@appfirst.com> if you have question about this.\r\n\r\nTo write your own, just extended the skeleton class AbstractStatsdClient and implement the method `doSend(String)`\r\n\r\n## Namespace\r\n-------------------\r\nTBD\r\n\r\n\r\n[collector]: https://wwws.appfirst.com\r\n"}